// Enhanced 3D Honey Jar Interactive
const honeyJar = document.getElementById('honeyJar');
let isDragging = false;
let currentX = 0;
let currentY = 0;
let initialX = 0;
let initialY = 0;
let xOffset = 0;
let yOffset = 0;
let rotationX = 0;
let rotationY = 0;

if (honeyJar) {
    // Mouse events
    honeyJar.addEventListener('mousedown', dragStart);
    document.addEventListener('mousemove', drag);
    document.addEventListener('mouseup', dragEnd);

    // Touch events for mobile
    honeyJar.addEventListener('touchstart', dragStart, { passive: false });
    document.addEventListener('touchmove', drag, { passive: false });
    document.addEventListener('touchend', dragEnd);

    // Mouse move for 3D effect without dragging
    let mouseX = 0;
    let mouseY = 0;
    let targetX = 0;
    let targetY = 0;
    let targetRotationX = 0;
    let targetRotationY = 0;

    honeyJar.parentElement.addEventListener('mousemove', (e) => {
        if (!isDragging) {
            const rect = honeyJar.parentElement.getBoundingClientRect();
            mouseX = e.clientX - rect.left - rect.width / 2;
            mouseY = e.clientY - rect.top - rect.height / 2;
            
            targetX = mouseX / 25;
            targetY = mouseY / 25;
            targetRotationY = mouseX / 15;
            targetRotationX = -mouseY / 15;
        }
    });

    function animate3D() {
        if (!isDragging) {
            xOffset += (targetX - xOffset) * 0.1;
            yOffset += (targetY - yOffset) * 0.1;
            rotationX += (targetRotationX - rotationX) * 0.1;
            rotationY += (targetRotationY - rotationY) * 0.1;
            
            honeyJar.style.transform = `
                translate(${xOffset}px, ${yOffset}px) 
                rotateY(${rotationY}deg) 
                rotateX(${rotationX}deg)
                perspective(1000px)
            `;
        }
        requestAnimationFrame(animate3D);
    }
    
    animate3D();
}

function dragStart(e) {
    if (honeyJar && (e.target === honeyJar || honeyJar.contains(e.target))) {
        isDragging = true;
        honeyJar.style.cursor = 'grabbing';
        
        if (e.type === "touchstart") {
            initialX = e.touches[0].clientX - xOffset;
            initialY = e.touches[0].clientY - yOffset;
        } else {
            initialX = e.clientX - xOffset;
            initialY = e.clientY - yOffset;
        }
    }
}

function drag(e) {
    if (isDragging && honeyJar) {
        e.preventDefault();
        
        if (e.type === "touchmove") {
            currentX = e.touches[0].clientX - initialX;
            currentY = e.touches[0].clientY - initialY;
        } else {
            currentX = e.clientX - initialX;
            currentY = e.clientY - initialY;
        }

        xOffset = currentX;
        yOffset = currentY;

        const rotateY = xOffset / 3;
        const rotateX = -yOffset / 3;
        const scale = 1.15;

        honeyJar.style.transform = `
            translate(${xOffset}px, ${yOffset}px) 
            rotateY(${rotateY}deg) 
            rotateX(${rotateX}deg) 
            scale(${scale})
            perspective(1000px)
        `;
    }
}

function dragEnd(e) {
    if (isDragging && honeyJar) {
        isDragging = false;
        honeyJar.style.cursor = 'grab';
        
        // Reset with smooth animation
        const resetAnimation = setInterval(() => {
            xOffset += (0 - xOffset) * 0.1;
            yOffset += (0 - yOffset) * 0.1;
            rotationX += (0 - rotationX) * 0.1;
            rotationY += (0 - rotationY) * 0.1;
            
            honeyJar.style.transform = `
                translate(${xOffset}px, ${yOffset}px) 
                rotateY(${rotationY}deg) 
                rotateX(${rotationX}deg)
                perspective(1000px)
            `;
            
            if (Math.abs(xOffset) < 0.1 && Math.abs(yOffset) < 0.1 && 
                Math.abs(rotationX) < 0.1 && Math.abs(rotationY) < 0.1) {
                clearInterval(resetAnimation);
                xOffset = 0;
                yOffset = 0;
                rotationX = 0;
                rotationY = 0;
            }
        }, 16);
    }
}

// Image Upload Functionality
document.addEventListener('DOMContentLoaded', function() {
    const imageUploads = document.querySelectorAll('.image-upload');
    
    imageUploads.forEach(upload => {
        // Create a hidden file input
        const fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.accept = 'image/*';
        fileInput.style.display = 'none';
        
        // Add click handler to placeholder
        const placeholder = upload.closest('.image-placeholder');
        if (placeholder) {
            placeholder.addEventListener('click', () => {
                fileInput.click();
            });
        }
        
        // Handle file selection
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const targetId = upload.dataset.target;
                    const placeholderId = upload.dataset.placeholder;
                    const img = document.getElementById(targetId);
                    const placeholder = document.getElementById(placeholderId);
                    
                    if (img) {
                        img.src = event.target.result;
                        img.style.display = 'block';
                    }
                    if (placeholder) {
                        placeholder.style.display = 'none';
                    }
                };
                reader.readAsDataURL(file);
            }
        });
        
        // Add drag and drop
        const galleryItem = upload.closest('.gallery-item');
        if (galleryItem) {
            galleryItem.addEventListener('dragover', (e) => {
                e.preventDefault();
                galleryItem.style.borderColor = '#25D366';
                galleryItem.style.transform = 'scale(1.02)';
            });
            
            galleryItem.addEventListener('dragleave', () => {
                galleryItem.style.borderColor = '';
                galleryItem.style.transform = '';
            });
            
            galleryItem.addEventListener('drop', (e) => {
                e.preventDefault();
                galleryItem.style.borderColor = '';
                galleryItem.style.transform = '';
                
                const file = e.dataTransfer.files[0];
                if (file && file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const targetId = upload.dataset.target;
                        const placeholderId = upload.dataset.placeholder;
                        const img = document.getElementById(targetId);
                        const placeholder = document.getElementById(placeholderId);
                        
                        if (img) {
                            img.src = event.target.result;
                            img.style.display = 'block';
                        }
                        if (placeholder) {
                            placeholder.style.display = 'none';
                        }
                    };
                    reader.readAsDataURL(file);
                }
            });
        }
        
        // Replace the upload button with file input
        upload.parentNode.replaceChild(fileInput, upload);
    });
});

// Smooth scroll for anchor links
document.querySelectorAll('a[href^="#"]').forEach(anchor => {
    anchor.addEventListener('click', function (e) {
        e.preventDefault();
        const target = document.querySelector(this.getAttribute('href'));
        if (target) {
            target.scrollIntoView({
                behavior: 'smooth',
                block: 'start'
            });
        }
    });
});

// Add animation on scroll with Intersection Observer
const observerOptions = {
    threshold: 0.1,
    rootMargin: '0px 0px -50px 0px'
};

const observer = new IntersectionObserver(function(entries) {
    entries.forEach(entry => {
        if (entry.isIntersecting) {
            entry.target.style.opacity = '1';
            entry.target.style.transform = 'translateY(0)';
            entry.target.classList.add('revealed');
        }
    });
}, observerOptions);

// Observe elements for scroll animations
document.addEventListener('DOMContentLoaded', function() {
    const animatedElements = document.querySelectorAll('.feature-section, .product-item, .price-card, .gallery-item, .tag');
    animatedElements.forEach((el, index) => {
        el.style.opacity = '0';
        el.style.transform = 'translateY(30px)';
        el.style.transition = `opacity 0.6s ease ${index * 0.1}s, transform 0.6s ease ${index * 0.1}s`;
        observer.observe(el);
    });

    // Add parallax effect to hero background
    window.addEventListener('scroll', () => {
        const scrolled = window.pageYOffset;
        const hero = document.querySelector('.hero');
        if (hero) {
            const rate = scrolled * 0.5;
            hero.style.backgroundPosition = `0% ${rate}px`;
        }
    });
});

// Add hover ripple effect to buttons
document.addEventListener('DOMContentLoaded', function() {
    const buttons = document.querySelectorAll('.btn');
    buttons.forEach(button => {
        button.addEventListener('click', function(e) {
            const ripple = document.createElement('span');
            const rect = this.getBoundingClientRect();
            const size = Math.max(rect.width, rect.height);
            const x = e.clientX - rect.left - size / 2;
            const y = e.clientY - rect.top - size / 2;
            
            ripple.style.width = ripple.style.height = size + 'px';
            ripple.style.left = x + 'px';
            ripple.style.top = y + 'px';
            ripple.classList.add('ripple');
            
            this.appendChild(ripple);
            
            setTimeout(() => {
                ripple.remove();
            }, 600);
        });
    });
});

// Product items interaction - redirect to WhatsApp
document.querySelectorAll('.product-item').forEach(item => {
    item.addEventListener('click', function() {
        const flavor = this.dataset.flavor;
        const flavorNames = {
            strawberry: 'клубнику',
            raspberry: 'малину',
            currant: 'смородину',
            honey: 'цветочный мёд'
        };
        
        const message = `Здравствуйте! Хочу заказать стики с ${flavorNames[flavor]}`;
        const whatsappUrl = `https://wa.me/77015315872?text=${encodeURIComponent(message)}`;
        window.open(whatsappUrl, '_blank');
    });
});

// Add CSS for ripple effect
const style = document.createElement('style');
style.textContent = `
    .btn {
        position: relative;
        overflow: hidden;
    }
    .ripple {
        position: absolute;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.6);
        transform: scale(0);
        animation: ripple-animation 0.6s ease-out;
        pointer-events: none;
    }
    @keyframes ripple-animation {
        to {
            transform: scale(4);
            opacity: 0;
        }
    }
    
    .revealed {
        opacity: 1 !important;
        transform: translateY(0) !important;
    }
    
    .gallery-item {
        transition: border-color 0.3s ease, transform 0.3s ease;
    }
`;
document.head.appendChild(style);

// Enhanced floating animation for shapes
document.addEventListener('DOMContentLoaded', function() {
    const shapes = document.querySelectorAll('.shape');
    shapes.forEach((shape, index) => {
        const randomDelay = Math.random() * 5;
        const randomDuration = 15 + Math.random() * 10;
        shape.style.animationDelay = `-${randomDelay}s`;
        shape.style.animationDuration = `${randomDuration}s`;
    });
});

// Add smooth reveal animation for sections
const revealObserver = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
        if (entry.isIntersecting) {
            entry.target.classList.add('revealed');
        }
    });
}, { threshold: 0.1 });

document.querySelectorAll('section').forEach(section => {
    revealObserver.observe(section);
});
